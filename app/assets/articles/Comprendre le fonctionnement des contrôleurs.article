--date 
11/05/2012

--tags
Routes, Contrôleurs, 

--introduction
Il peut être naturel d'avoir des ressources qui appartiennent à d'autre ressources. C'est dans ce cas là qu'il peut être intéressant d'utiliser des ressources imbriquées aux niveaux des routes pour avoir des URLs cohérente.

--title
Comprendre le fonctionement Contrôleurs-Vues

--authors
Nicolas

--content

.require
  Pré-requis :
  %ul
    %li 
      Avoir comrpis le
      %a{:target => '_blank', :href => "http://ontherailsagain.com/articles/comprendre-les-routes-en-rails" } fonctionnement des routes</a>.
    %li 
      Avoir vu le 
      %a{:target => '_blank', :href => "http://ontherailsagain.com/articles/le-routage-de-ressources-en-rails" } routage de ressources</a>.

.see
  Ce que nous allons voir :
  %ul
    %li Déclarer les ressources imbriquées au niveau des routes.
    %li Adapter les contrôleurs et les vues pour gérer ces ressources imbriquées.

%h2 Ce que fait un contrôleur

%h3 Son rôle dans le modèle MVC

%p Dans le modèle MVC, le contrôleur constitue le lien entre le modèle et la vue. C'est-à-dire que dans un sens, le contrôleur va récupérer des informations du modèle pour les fournir à la vue. Dans l'autre sens, le contrôleur va récupérer les informations de la vue, comme par exemple les informations contenues dans un formulaire, et créer ou modifier des objets du modèle. 


%h3 Son rôle dans Ruby On Rails
%p Dans Ruby On Rails, le rôle du contrôleur est de 

%h2 Méthodes et Actions

%p Nous avons vu dans le fonctionnement des routes que lorsque l'application reçoit une requête, les routes déterminent quel contrôleur et quelle action utiliser. A partir de ça, Rails crée une instance de ce contrôleur, qui est une classe Ruby comme n'importe quelle autre classe, et execute la méthode qui à le même nom que l'action souhaitée.

%p.alert.alert-info Seulement les méthodes publiques sont éxecutables comme des actions. C'est d'ailleurs une bonne pratique de déclarer privée les methodes qui ne sont pas prévues pour être des actions comme par exemple des méthodes de traitement auxiliaires ou encore des <code>filters</code>.

%h3 Fonctionnement par défaut

%p Par défaut, Rails utilise le fichier de vue qui a le même nom que celui de la méthode éxecutée. Prenons un exemple, supposons que nous ayons le contrôleur <code>ArticlesController</code> défini de la façon suivante :

%pre.ruby
  :preserve
    # app/controllers/articles_controller.rb
    class ArticlesController < ApplicationController
        def new
        end
    end

%p Supposons également que les routes soient bien définies comme ceci :

%pre.ruby
  :preserve
    # config/routes.rb
    resources :articles

%p Si l'utilisateur accède à l'URL <code>/articles/new</code> pour créer un nouvel article, Rails va créer une instance du contrôleur <code>ArticlesController</code>, éxecuter la méthode <code>new</code> et utiliser le fichier de vue <code>app/view/articles/new.html.erb</code> et ce, même si la méthode <code>new</code> ne fait absolument rien.

%h3 Comment ça fonctionne ?

%p Tout d'abord, il faut savoir que depuis un contrôleur, il y a trois façons pour créer une réponse HTTP :

%ul
  %li Utiliser la méthode <code>render</code> qui permet de créer une réponse HTTP complète à envoyer au navigateur
  %li Utiliser la méthode <code>redirect_to</code> qui permet d'envoyer un code de redirection HTTP au navigateur et permet donc de rediriger vers une URL 
  %li Utiliser la méthode <code>head</code> qui permet de créer une réponse HTTP contenant uniquement l'entête à envoyer au navigateur.

%p Nous allons nous focaliser sur les deux premières méthodes qui sont les plus souvent utilisées, mais pour en savoir plus voici un article sur <a href="http://www.alsacreations.com/astuce/lire/1152-en-tetes-http.html" target="_blank">les entêtes HTTP</a>.

%p Par défaut, si rien n'est précisé, le contrôleur fait un appel à la méthode <code>render</code> et execute donc la vue ayant le même nom que celle-ci, c'est un bon exemple de « Convention Over Configuration » dont on entend souvent parler avec Ruby On Rails.


%h2 Variables accessibles dans la vue

%p L'exemple précedent ne fait rien, et si nous voulons réellement créer un article il faudrait modifier la méthode <code>new</code> de la façon suivante :

%pre.ruby
  :preserve
    # app/controllers/articles_controller.rb
    class ArticlesController < ApplicationController
        def new
          @article = Article.new
        end
    end

%p En créant une variable avec un <code>@</code>, on crée une variable d'instance, c'est à dire que cette variable est accessible tout au long de la vie de l'objet et depuis n'importe quel endroit de l'objet. Ainsi, cette instance du modèle <code>Article</code> sera accessible dans la vue <code>app/view/articles/new.html.erb</code> et l'utilisateur pourra effectuer des modifications dessus.

%h2 Paramètres et données utilisateurs

%p Il est très fréquent d'avoir besoin de récupérer les données envoyées par l'utilisateur ou même des paramètres que vous définissez vous-même pour modifier le comportement des actions.

%p Il existe deux types de paramètres possibles dans une application Web. 
Tout d'abord, les paramètres passés dans l'URL et donc passé par la méthode HTTP <code>GET</code>. Ils correspondent à l'ensemble de ce qui est écrit dans l'URL aprsè le caractère <code>?</code>.
Ensuite, les paramètres passés par la méthode HTTP <code>POST</code> qui viennent généralement d'un formulaire HTML qui à été rempli par l'utilisateur.

%p Rails ne fait aucune distinction entre ces deux types de paramètres, et les deux sont accessible via le <a href="http://ruby-doc.org/docs/beginner-fr/xhtml/ch03s04.html" target="_blank">hash</a> <code>params</code> dans le contrôleur. Voici un exemple de paramètre passé par la méthode <code>GET</code> :

%pre.ruby
  :preserve
    #URL
    /articles/new?demo=true

    # app/controllers/articles_controller.rb
    params[:demo] # contient "true"




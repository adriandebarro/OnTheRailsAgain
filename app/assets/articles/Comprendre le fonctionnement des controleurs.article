--date 
11/05/2012

--tags
Routes, Contrôleurs, 

--introduction
Il peut être naturel d'avoir des ressources qui appartiennent à d'autre ressources. C'est dans ce cas là qu'il peut être intéressant d'utiliser des ressources imbriquées aux niveaux des routes pour avoir des URLs cohérente.

--title
Comprendre le fonctionement Contrôleurs-Vues

--authors
Nicolas

--content

.require
  Pré-requis :
  %ul
    %li 
      Avoir quelques notions de MVC
    %li 
      Avoir compris le
      %a{:target => '_blank', :href => "http://ontherailsagain.com/articles/comprendre-les-routes-en-rails" } fonctionnement des routes</a>.

.see
  Ce que nous allons voir :
  %ul
    %li Déclarer les ressources imbriquées au niveau des routes.
    %li Adapter les contrôleurs et les vues pour gérer ces ressources imbriquées.

%h2 Ce que fait le Contrôleur

%h3 Son rôle dans le modèle MVC

%p Dans le modèle MVC, le contrôleur constitue le lien entre le modèle et la vue. C'est-à-dire que dans un sens, le contrôleur va récupérer des informations du modèle pour les fournir à la vue. Dans l'autre sens, le contrôleur va récupérer les informations de la vue, comme par exemple les informations contenues dans un formulaire, et créer ou modifier des objets du modèle. 


%h3 Son rôle dans Ruby On Rails

%p Le contrôleur et la vue ayant un fonctionnement fortement couplé, ils sont tous deux regroupés dans un seul composant de Ruby On Rails : ActionPack. Cependant, ce n'est pas parce qu'il sont dans le même composant que le code de l'un est directement partagé avec l'autre et vice-versa. Au contraire, Rails fournit tous les outils pour avoir une bonne démarcation entre contrôle et la logique de présentation. 

%p Le contrôleur Rails est le centre logique de notre application. Il coordonne l'interaction entre l'utilisateur, les vues, et le modèle. Cependant, Rails gère la plupart de cette interaction et le code que nous devons écrire se concentre sur les fonctionnalités de l'application. Le code du contrôleur Rails est donc très facile à développer et à maintenir.
%p Le contrôleur gère un certain nombre d'importants services auxiliaires:
%ul
%li Il est responsable de faire correspondre les requêtes exterieures avec les actions internes. Grâce aux <code>path_helper</code> il permet de gérer les URLs facilement et que celles-ci soient lisibles.
%li Il s'occupe de la mise en cache.
%li Il gère les modules auxiliaires, les <code>helpers</code>, qui permettent de factoriser du code de la vue.
%li Il gère les sessions.

%h2 Ce que fait la Vue

%h3 Son rôle dans le modèle MVC

%p La vue est responsable de générer une interface utilisateur basée sur les données du modèle. Par exemple, une boutique en ligne aura une liste de produits à afficher dans un catalogue. Cette liste sera accessible via le modèle, mais ce sera la vue qui accèdera à la liste à partir du modèle et qui sera chargée de la formater pour l'afficher à l'utilisateur final.

%p Même si la vue sert à présenter la saisie de donnée à l'utilisateur, elle ne traite jamais les données entrantes. Le travail de la vue est effectuée une fois que les données sont affichées.

%p Il peut y avoir de nombreuses vues qui accèdent aux données du même modèle à des fins différentes. Par exemple, dans la boutique en ligne, il y aura une vue qui affiche des informations produit sur une page de catalogue et un autre ensemble de vues utilisées par les administrateurs pour ajouter et modifier des produits.

%h3 Son rôle dans Ruby On Rails

%p Dans Rails, la vue est responsable de créer l'ensemble ou une partie de la réponse à afficher dans la navigateur de l'utilisateur. Dans les cas les plus simples la vue est un morceau de code HTML statique. Mais plus généralement, nous avons besoin d'inclure du contenu dynamique, en créant par exemple un vue qui affiche les attributs d'un modèle, et ce en utlisant la variable représentant le modèle instancié dans le contrôleur.

%p Dans Rails, le contenu dynamique est généré par les templates. Les templates les plus communs sont les fichiers ERb (Embedded Ruby). Ils contiennent du code Ruby et du code HTML. Bien que cette approche soit très flexible il est important de ne pas casser l'esprit du MVC. Et même si la vue contient du code Ruby, il ne faut pas y mettre du code qui devrait être dans le modèle ou le contrôleur.

%h2 Méthodes et Actions

%p Nous avons vu dans le fonctionnement des routes que lorsque l'application reçoit une requête, les routes déterminent quel contrôleur et quelle action utiliser. A partir de ça, Rails crée une instance de ce contrôleur, qui est une classe Ruby comme n'importe quelle autre classe, et execute la méthode qui à le même nom que l'action souhaitée.

%p.alert.alert-info Seulement les méthodes publiques sont éxecutables comme des actions. C'est d'ailleurs une bonne pratique de déclarer privée les methodes qui ne sont pas prévues pour être des actions comme par exemple des méthodes de traitement auxiliaires ou encore des <code>filters</code>.

%p D'ailleurs, en général, nous devons nous efforcer d'avoir des gros modèles et des petits contrôleurs. Les méthodes des contrôleurs ne devraient contenir que très peu de lignes de code. Si une action contrôleur devient trop grosse, alors nous devons essayer de sortir la logique et l'inclure dans le modèle.

%h2 Exemple

%h3 Fonctionnement par défaut

%p Par défaut, Rails utilise le fichier de vue qui a le même nom que celui de la méthode éxecutée. Prenons un exemple, supposons que nous ayons le contrôleur <code>ArticlesController</code> défini de la façon suivante :

%pre.ruby
  :preserve
    # app/controllers/articles_controller.rb
    class ArticlesController < ApplicationController
        def new
        end
    end

%p Supposons également que les routes soient bien définies comme ceci :

%pre.ruby
  :preserve
    # config/routes.rb
    resources :articles

%p Si l'utilisateur accède à l'URL <code>/articles/new</code> pour créer un nouvel article, Rails va créer une instance du contrôleur <code>ArticlesController</code>, éxecuter la méthode <code>new</code> et utiliser le fichier de vue <code>app/view/articles/new.html.erb</code> et ce, même si la méthode <code>new</code> ne fait absolument rien.

%h3 Comment ça fonctionne ?

%p Tout d'abord, il faut savoir que depuis un contrôleur, il y a trois façons pour créer une réponse HTTP :

%ul
  %li Utiliser la méthode <code>render</code> qui permet de créer une réponse HTTP complète à envoyer au navigateur
  %li Utiliser la méthode <code>redirect_to</code> qui permet d'envoyer un code de redirection HTTP au navigateur et permet donc de rediriger vers une URL 
  %li Utiliser la méthode <code>head</code> qui permet de créer une réponse HTTP contenant uniquement l'entête à envoyer au navigateur.

%p.alert.alert-info Pour en savoir plus voici un article sur <a href="http://www.alsacreations.com/astuce/lire/1152-en-tetes-http.html" target="_blank">les entêtes HTTP</a>.

%p Par défaut, si rien n'est précisé, le contrôleur fait un appel à la méthode <code>render</code> et execute donc la vue ayant le même nom que celle-ci, c'est un bon exemple de « Convention Over Configuration » dont on entend souvent parler avec Ruby On Rails.


%h2 Variables accessibles dans la vue

%p L'exemple précedent ne fait rien, et si nous voulons réellement créer un article il faudrait modifier la méthode <code>new</code> de la façon suivante :

%pre.ruby
  :preserve
    # app/controllers/articles_controller.rb
    class ArticlesController < ApplicationController
        def new
          @article = Article.new
        end
    end

%p En créant une variable avec un <code>@</code>, on crée une variable d'instance, c'est à dire que cette variable est accessible tout au long de la vie de l'objet. Ainsi, cette instance du modèle <code>Article</code> sera accessible dans la vue <code>app/view/articles/new.html.erb</code> et l'utilisateur pourra effectuer des modifications dessus.

%h2 Paramètres et données utilisateurs

%p Il est très fréquent d'avoir besoin de récupérer les données envoyées par l'utilisateur ou même des paramètres que vous définissez vous-même pour modifier le comportement des actions.

%p Il existe deux types de paramètres possibles dans une application Web. 
Tout d'abord, les paramètres passés dans l'URL et donc passé par la méthode HTTP <code>GET</code>. Ils correspondent à l'ensemble de ce qui est écrit dans l'URL aprsè le caractère <code>?</code>.
Ensuite, les paramètres passés par la méthode HTTP <code>POST</code> qui viennent généralement d'un formulaire HTML qui à été rempli par l'utilisateur.

%p Rails ne fait aucune distinction entre ces deux types de paramètres, et les deux sont accessible via le <a href="http://ruby-doc.org/docs/beginner-fr/xhtml/ch03s04.html" target="_blank">hash</a> <code>params</code> dans le contrôleur. Voici un exemple de paramètre passé par la méthode <code>GET</code> :

%pre.ruby
  :preserve
    #URL
    /articles/new?demo=true

    # app/controllers/articles_controller.rb
    params[:demo] # contient "true"



